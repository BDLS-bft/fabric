// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: message.proto

package bdls

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MessageType defines supported message types
type MessageType int32

const (
	// No operation, for default message type, and keepalive connection
	MessageType_Nop MessageType = 0
	// MessageRoundChange = <roundchange> message
	MessageType_RoundChange MessageType = 1
	// MessageLock = <lock> message
	MessageType_Lock MessageType = 2
	// MessageSelect = <select> message
	MessageType_Select MessageType = 3
	// MessageCommit = <commit> message
	MessageType_Commit MessageType = 4
	// MessageLockRelease = <lock-release> message
	MessageType_LockRelease MessageType = 5
	// MessageDecide = <decide> message
	MessageType_Decide MessageType = 6
	// MessageResync= <resync> message
	MessageType_Resync MessageType = 7
)

var MessageType_name = map[int32]string{
	0: "Nop",
	1: "RoundChange",
	2: "Lock",
	3: "Select",
	4: "Commit",
	5: "LockRelease",
	6: "Decide",
	7: "Resync",
}

var MessageType_value = map[string]int32{
	"Nop":         0,
	"RoundChange": 1,
	"Lock":        2,
	"Select":      3,
	"Commit":      4,
	"LockRelease": 5,
	"Decide":      6,
	"Resync":      7,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{0}
}

// SignedProto defines a message with signature and it's publickey
type SignedProto struct {
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Message []byte `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// go back to the old X, Y, and curve_type fields
	X         []byte `protobuf:"bytes,4,opt,name=X,proto3" json:"X,omitempty"`
	Y         []byte `protobuf:"bytes,5,opt,name=Y,proto3" json:"Y,omitempty"`
	CurveType []byte `protobuf:"bytes,3,opt,name=CurveType,proto3" json:"CurveType,omitempty"`
	R         []byte `protobuf:"bytes,6,opt,name=R,proto3" json:"R,omitempty"`
	S         []byte `protobuf:"bytes,7,opt,name=S,proto3" json:"S,omitempty"`
}

func (m *SignedProto) Reset()         { *m = SignedProto{} }
func (m *SignedProto) String() string { return proto.CompactTextString(m) }
func (*SignedProto) ProtoMessage()    {}
func (*SignedProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{0}
}
func (m *SignedProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedProto.Merge(m, src)
}
func (m *SignedProto) XXX_Size() int {
	return m.Size()
}
func (m *SignedProto) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedProto.DiscardUnknown(m)
}

var xxx_messageInfo_SignedProto proto.InternalMessageInfo

func (m *SignedProto) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SignedProto) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *SignedProto) GetX() []byte {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *SignedProto) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *SignedProto) GetCurveType() []byte {
	if m != nil {
		return m.CurveType
	}
	return nil
}

func (m *SignedProto) GetR() []byte {
	if m != nil {
		return m.R
	}
	return nil
}

func (m *SignedProto) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

// Message defines a consensus message
type Message struct {
	// Type of this message
	Type MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=bdls.MessageType" json:"Type,omitempty"`
	// Height in consensus
	Height uint64 `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	// Round in consensus
	Round uint64 `protobuf:"varint,3,opt,name=Round,proto3" json:"Round,omitempty"`
	// Proposed state (optional)
	State []byte `protobuf:"bytes,4,opt,name=State,proto3" json:"State,omitempty"`
	// Proofs related
	Proof []*SignedProto `protobuf:"bytes,5,rep,name=Proof,proto3" json:"Proof,omitempty"`
	// for lock-release, it's an embeded <lock> message
	LockRelease *SignedProto `protobuf:"bytes,6,opt,name=LockRelease,proto3" json:"LockRelease,omitempty"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_33c57e4bae7b9afd, []int{1}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetType() MessageType {
	if m != nil {
		return m.Type
	}
	return MessageType_Nop
}

func (m *Message) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Message) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *Message) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Message) GetProof() []*SignedProto {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *Message) GetLockRelease() *SignedProto {
	if m != nil {
		return m.LockRelease
	}
	return nil
}

func init() {
	proto.RegisterEnum("bdls.MessageType", MessageType_name, MessageType_value)
	proto.RegisterType((*SignedProto)(nil), "bdls.SignedProto")
	proto.RegisterType((*Message)(nil), "bdls.Message")
}

func init() { proto.RegisterFile("message.proto", fileDescriptor_33c57e4bae7b9afd) }

var fileDescriptor_33c57e4bae7b9afd = []byte{
	// 383 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0x4d, 0xeb, 0xd3, 0x40,
	0x10, 0xc6, 0xb3, 0xcd, 0x9b, 0x4e, 0x5a, 0x5d, 0x17, 0x91, 0x45, 0x24, 0x94, 0x82, 0x58, 0x04,
	0x53, 0xb0, 0xdf, 0xc0, 0x7a, 0xf0, 0xa0, 0x52, 0x36, 0x1e, 0xda, 0x63, 0x5e, 0xa6, 0x69, 0xb0,
	0xc9, 0x96, 0xbc, 0x14, 0xfa, 0x2d, 0xbc, 0xf9, 0x95, 0x3c, 0x16, 0x4f, 0x1e, 0xa5, 0xfd, 0x22,
	0xb2, 0x9b, 0x14, 0x73, 0xf8, 0xdf, 0xe6, 0x37, 0xcf, 0x33, 0x33, 0xcf, 0x86, 0xc0, 0xa4, 0xc0,
	0xba, 0x8e, 0x32, 0x0c, 0x8e, 0x95, 0x6c, 0x24, 0xb3, 0xe2, 0xf4, 0x50, 0xbf, 0x7c, 0x97, 0xe5,
	0xcd, 0xbe, 0x8d, 0x83, 0x44, 0x16, 0x8b, 0x4c, 0x66, 0x72, 0xa1, 0xc5, 0xb8, 0xdd, 0x69, 0xd2,
	0xa0, 0xab, 0x6e, 0x68, 0xf6, 0x93, 0x80, 0x17, 0xe6, 0x59, 0x89, 0xe9, 0x5a, 0x2f, 0xe1, 0xe0,
	0x9e, 0xb0, 0xaa, 0x73, 0x59, 0x72, 0x32, 0x25, 0xf3, 0x89, 0xb8, 0xa3, 0x52, 0xfa, 0x7b, 0x7c,
	0x34, 0x25, 0xf3, 0xb1, 0xb8, 0x23, 0x1b, 0x03, 0xd9, 0x70, 0x4b, 0xf7, 0xc8, 0x46, 0xd1, 0x96,
	0xdb, 0x1d, 0x6d, 0xd9, 0x2b, 0x78, 0xbc, 0x6a, 0xab, 0x13, 0x7e, 0x3b, 0x1f, 0x91, 0x9b, 0xba,
	0xfb, 0xbf, 0xa1, 0xbc, 0x82, 0x3b, 0x9d, 0x57, 0x28, 0x0a, 0xb9, 0xdb, 0x51, 0x38, 0xfb, 0x4d,
	0xc0, 0xfd, 0xd2, 0x5f, 0x78, 0x0d, 0x96, 0x5e, 0xa0, 0x22, 0x3d, 0x79, 0xff, 0x2c, 0x50, 0x2f,
	0x0d, 0x7a, 0x51, 0x09, 0x42, 0xcb, 0xec, 0x05, 0x38, 0x9f, 0x30, 0xcf, 0xf6, 0x8d, 0x4e, 0x68,
	0x89, 0x9e, 0xd8, 0x73, 0xb0, 0x85, 0x6c, 0xcb, 0x54, 0x07, 0xb0, 0x44, 0x07, 0xaa, 0x1b, 0x36,
	0x51, 0x83, 0x7d, 0xf4, 0x0e, 0xd8, 0x1b, 0xb0, 0xd7, 0x95, 0x94, 0x3b, 0x6e, 0x4f, 0xcd, 0xb9,
	0x77, 0xbf, 0x35, 0xf8, 0x44, 0xa2, 0xd3, 0xd9, 0x12, 0xbc, 0xcf, 0x32, 0xf9, 0x2e, 0xf0, 0x80,
	0x51, 0x8d, 0xfa, 0x15, 0x0f, 0xda, 0x87, 0xae, 0xb7, 0x15, 0x78, 0x83, 0xd8, 0xcc, 0x05, 0xf3,
	0xab, 0x3c, 0x52, 0x83, 0x3d, 0x05, 0x4f, 0x87, 0x5a, 0xed, 0xa3, 0x32, 0x43, 0x4a, 0xd8, 0x23,
	0xb0, 0xd4, 0x1c, 0x1d, 0x31, 0x00, 0x27, 0xc4, 0x03, 0x26, 0x0d, 0x35, 0x55, 0xbd, 0x92, 0x45,
	0x91, 0x37, 0xd4, 0x52, 0x23, 0x83, 0xcd, 0xd4, 0x56, 0xe2, 0x47, 0x4c, 0xf2, 0x14, 0xa9, 0xa3,
	0x6a, 0x81, 0xf5, 0xb9, 0x4c, 0xa8, 0xfb, 0x81, 0xff, 0xba, 0xfa, 0xe4, 0x72, 0xf5, 0xc9, 0xdf,
	0xab, 0x4f, 0x7e, 0xdc, 0x7c, 0xe3, 0x72, 0xf3, 0x8d, 0x3f, 0x37, 0xdf, 0x88, 0x1d, 0xfd, 0x0f,
	0x2c, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0xf9, 0xfa, 0xf5, 0x2f, 0x49, 0x02, 0x00, 0x00,
}

func (m *SignedProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.S) > 0 {
		i -= len(m.S)
		copy(dAtA[i:], m.S)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.S)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.R) > 0 {
		i -= len(m.R)
		copy(dAtA[i:], m.R)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.R)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Y) > 0 {
		i -= len(m.Y)
		copy(dAtA[i:], m.Y)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Y)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.X) > 0 {
		i -= len(m.X)
		copy(dAtA[i:], m.X)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.X)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CurveType) > 0 {
		i -= len(m.CurveType)
		copy(dAtA[i:], m.CurveType)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.CurveType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LockRelease != nil {
		{
			size, err := m.LockRelease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Proof) > 0 {
		for iNdEx := len(m.Proof) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Proof[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x22
	}
	if m.Round != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SignedProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovMessage(uint64(m.Version))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.CurveType)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.X)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Y)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.R)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	if m.Height != 0 {
		n += 1 + sovMessage(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovMessage(uint64(m.Round))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.Proof) > 0 {
		for _, e := range m.Proof {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.LockRelease != nil {
		l = m.LockRelease.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SignedProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurveType", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurveType = append(m.CurveType[:0], dAtA[iNdEx:postIndex]...)
			if m.CurveType == nil {
				m.CurveType = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X = append(m.X[:0], dAtA[iNdEx:postIndex]...)
			if m.X == nil {
				m.X = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Y = append(m.Y[:0], dAtA[iNdEx:postIndex]...)
			if m.Y == nil {
				m.Y = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.R = append(m.R[:0], dAtA[iNdEx:postIndex]...)
			if m.R == nil {
				m.R = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = append(m.S[:0], dAtA[iNdEx:postIndex]...)
			if m.S == nil {
				m.S = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = append(m.Proof, &SignedProto{})
			if err := m.Proof[len(m.Proof)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockRelease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockRelease == nil {
				m.LockRelease = &SignedProto{}
			}
			if err := m.LockRelease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
